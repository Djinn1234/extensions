// Matcher Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
/*
 * File:   {{.Matchername | ToLower}}.hpp
 *
 */
{{- $fields := .CachedFields|Sort}}
{{- $matcher_name := .Matchername}}
{{- $cache_keys := .CachedFields|GetFieldKeys}}
{{- $fields_length := len $fields}}

#pragma once
#ifndef {{.Matchername|ToUpper}}_HPP
#define {{.Matchername|ToUpper}}_HPP

#if __APPLE_CC__
#if __cplusplus >= 201402L
#define STRING_VIEW_DEFINED 1
#endif
#elif __GNUC__
#if __cplusplus >= 201703L
#define STRING_VIEW_DEFINED 1
#endif
#endif


#include <string>
#include <cstdint>
#include <iostream>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/composite_key.hpp>
#include "rtb/datacache/any_str_ops.hpp"
#include "rtb/common/split_string.hpp"
#include "core/tagged_tuple.hpp"

struct {{.Matchername|Title}} {
    {{range $field := $fields -}}
    {{$field.FieldType}} {{$field.FieldName}};
    {{end}}
    {{.Matchername|Title}}( {{range $i,$field := $fields}} {{$field.FieldType}} &&{{$field.FieldName}}{{if NotLast $i $fields}},{{end}}{{end}}) : {{range $i,$field := $fields}}{{$field.FieldName}}{ {{$field.FieldName}} }{{if NotLast $i $fields}}, {{end}}{{end}}
    {}

    {{.Matchername|Title}}(): {{range $i,$field := $fields}}{{$field.FieldName}}{}{{if NotLast $i $fields}}, {{end}}{{end}}
    {}

    friend std::ostream &operator<<(std::ostream & os, const std::shared_ptr<{{.Matchername|Title}}> &value_ptr) {
        os << *value_ptr;
        return os;
    }
    friend std::ostream &operator<<(std::ostream & os, const {{.Matchername|Title}} &value)  {
        os
        {{- range $i,$field := $fields -}}
           << value.{{$field.FieldName}}{{if NotLast $i $fields}} << "|"{{end}}
        {{- end -}};
        return os;
    }
    friend std::istream &operator>>(std::istream &is, {{.Matchername|Title}} &value) {
        std::string record;
        if ( !std::getline(is, record) ){
            return is;
        }
#if defined(STRING_VIEW_DEFINED)
        std::vector<std::string_view> fields;
        vanilla::common::split_string(fields, record, "\t");
#else
        std::vector<std::string> fields;
        boost::split(fields, record, boost::is_any_of("\t"), boost::token_compress_on);
#endif
        if(fields.size() < {{$fields_length}} ) {
            return is;
        }
        {{range $i,$field := $fields -}}
        {{if  eq $field.FieldType "std::string" -}}
        value.{{$field.FieldName}} = fields.at({{$i}});
        {{else -}}
        value.{{$field.FieldName}} = boost::lexical_cast<{{$field.FieldType}}>(fields.at({{$i}}));
        {{end -}}
        {{end -}}
        return is;
    }
};


namespace ipc { namespace data {

    template <typename Alloc>
    struct {{.Matchername|ToLower}}_entity {
        using shared_string =  boost::interprocess::basic_string<char, std::char_traits<char>, Alloc>;

        //for tagging in multi_index_container
        struct tag {}; // search on key
        {{range $field := $fields -}}
        {{if (IsKey $field) -}}
        struct {{$field.FieldName}}_tag {};
        {{end -}}
        {{end}}

        {{.Matchername|ToLower}}_entity( const Alloc & a ) : alloc{a},
        {{- range $i,$field := $fields -}}
        {{$field.FieldName}}
        {{- if (and (IsKey $field) (IsIPC $field)) -}}
        {a}
        {{- else -}}
        {}
        {{- end -}}
        {{if NotLast $i $fields}}, {{end -}}
        {{end}}
        {} //end-of-ctor

        Alloc alloc;
        {{range $field := $fields -}}
        {{$field.FieldTypeIPC}} {{$field.FieldName}};
        {{end}}

        template<typename Key, typename Serializable>
        void store(Key && key, Serializable  &&data)  {
           {{range $i,$field := $fields -}}
           {{if (and (IsKey $field) (IsIPC $field)) -}}
           auto value{{$i}} = key.template get<{{$field.FieldName}}_tag>();
           {{$field.FieldName}} = {{$field.FieldTypeIPC}}(value{{$i}}.data(), value{{$i}}.size(), alloc);
           {{else -}}
           {{if IsIPC $field -}}
           {{$field.FieldName}} = {{$field.FieldTypeIPC}}(data.{{$field.FieldName}}.data(), data.{{$field.FieldName}}.size(), alloc);
           {{else -}}
           {{$field.FieldName}} = data.{{$field.FieldName}};
           {{end -}}
           {{end -}}
           {{end}}
        }

        template<typename Serializable>
        void retrieve(Serializable  & data) const {
           {{range $i,$field := $fields -}}
           {{if IsIPC $field -}}
           data.{{$field.FieldName}} = std::move(std::string({{$field.FieldName}}.data(), {{$field.FieldName}}.size()));
           {{else -}}
           data.{{$field.FieldName}} = {{$field.FieldName}};
           {{end -}}
           {{end}}
        }
        //needed for ability to update after matching by calling index.modify(itr,entry)
        void operator()({{.Matchername|ToLower}}_entity &entry) const {
            {{range $field := $fields -}}
            entry.{{$field.FieldName}}={{$field.FieldName}};
            {{end}}
        }
    };

    template<typename Alloc>
    using {{.Matchername|ToLower}}_container =
    boost::multi_index_container<
        {{.Matchername|ToLower}}_entity<Alloc>,
        boost::multi_index::indexed_by<
            boost::multi_index::ordered_unique<
                  boost::multi_index::tag<typename {{.Matchername|ToLower}}_entity<Alloc>::tag>,
                  boost::multi_index::composite_key<
                      {{.Matchername|ToLower}}_entity<Alloc>,
                      {{range $i,$field := $fields -}}
                      {{if IsIPC $field -}}
                      BOOST_MULTI_INDEX_MEMBER({{$matcher_name|ToLower}}_entity<Alloc>,typename {{$matcher_name|ToLower}}_entity<Alloc>::{{$field.FieldTypeIPC}},{{$field.FieldName}}) {{if NotLast $i $fields}},{{end}}
                      {{else -}}
                      BOOST_MULTI_INDEX_MEMBER({{$matcher_name|ToLower}}_entity<Alloc>,{{$field.FieldType}},{{$field.FieldName}}) {{if NotLast $i $fields}},{{end}}
                      {{end -}}
                      {{end -}}
                  >,
                  boost::multi_index::composite_key_compare<
                      {{range $i,$field := $fields -}}
                      {{if IsIPC $field -}}
                      ufw::any_str_less<Alloc>{{else -}}
                      std::less<{{$field.FieldType}}>
                      {{end -}}
                      {{if NotLast $i $fields}} , {{end -}}
                      {{end -}}
                  >
            >
        >,
        boost::interprocess::allocator<{{.Matchername|Title}},typename Alloc::segment_manager>
    > ;
}}

template <typename Config,
          typename Memory = typename mpclmi::ipc::Shared,
          typename Alloc = typename datacache::entity_cache<Memory, ipc::data::{{.Matchername|ToLower}}_container>::char_allocator >
class {{.Matchername|Title}}Entity {
        using Cache = datacache::entity_cache<Memory, ipc::data::{{.Matchername|ToLower}}_container> ;
        using Tag = typename ipc::data::{{.Matchername|ToLower}}_entity<Alloc>::tag;
        using Keys = vanilla::tagged_tuple<
        {{- range $i,$key := $cache_keys -}}
        typename ipc::data::{{$matcher_name|ToLower}}_entity<Alloc>::{{$key.FieldName}}_tag, {{$key.FieldType}}{{if NotLast $i $cache_keys}},{{end}}
        {{- end -}}
        >;
        using {{.Matchername|Title}}Collection = std::vector<{{.Matchername|Title}}>;
    public:
        {{.Matchername|Title}}Entity(const Config &config):
            config{config}, cache(config.data().{{.Matchername|ToLower}}_ipc_name)
        {}
        void load() noexcept(false) {
            std::ifstream in{config.data().{{.Matchername|ToLower}}_source};
            if (!in) {
                throw std::runtime_error(std::string("could not open file ") + config.data().{{.Matchername|ToLower}}_source + " exiting...");
            }
            LOG(debug) << "File opened " << config.data().{{.Matchername|ToLower}}_source;
            cache.clear();

            std::for_each(std::istream_iterator<{{.Matchername|Title}}>(in), std::istream_iterator<{{.Matchername|Title}}>(), [&](const {{.Matchername|Title}} &value){
                //using namespace boost::algorithm;
                //if(!cache.insert(Keys{to_lower_copy(value.key)}, value).second) {
                if(!cache.insert(Keys{
                {{- range $i,$key := $cache_keys -}}
                value.{{$key.FieldName}}{{if NotLast $i $cache_keys}},{{end}}
                {{- end -}}
                }, value).second) {
                    LOG(debug) << "Adding " << value << " failed!";
                } else {
                    LOG(debug) << "Adding " << value << " done!";
                }
            });
        }

        template<typename ...Args>
        bool retrieve({{.Matchername|Title}} &value, Args && ...args) {
            return cache.template retrieve<Tag>(value, std::forward<Args>(args)...);
        }

        template<typename ...Args>
        bool retrieve({{.Matchername|Title}} &value, std::tuple<Args...> & tuple) {
            return this->retrieve<Tag>(value, tuple , std::make_index_sequence<sizeof...(Args)>());
        }

        template<typename ...Args, size_t... Is>
        bool retrieve({{.Matchername|Title}} &value, std::tuple<Args...> & tuple, std::index_sequence<Is...>) {
            return cache.template retrieve<Tag>(value, std::get<Is>(tuple)...);
        }

        template<typename ...Args>
        bool retrieve({{.Matchername|Title}}Collection &collection, Args && ...args) {
            auto p = cache.template retrieve_raw<Tag>(std::forward<Args>(args)...);
            auto is_found = p.first != p.second;
            collection.reserve(500); //TODO: add this number as an option in stub's object Tag
            while ( p.first != p.second ) {
                {{.Matchername|Title}} data;
                p.first->retrieve(data);
                collection.emplace_back(std::move(data));
                ++p.first;
            }
        return is_found;
        }

    private:
        const Config &config;
        Cache cache;

};

#endif /* {{.Matchername|ToUpper}}_HPP */
